## 进程控制

### 6.1进程标识

UNIX系统中，每个进程都有一个唯一的非负整型ID来标识。系统中有一些专用的进程ID，例如：ID为0的进程是调度进程（或者叫交换进程），ID为1的进程是init进程（自举结束后用于初始化系统），ID为2的进程通常是守护进程。

`注意：init进程是普通的用于进程，但是以超级用户的特权执行。且是所有孤儿进程的父进程！` 

除了进程ID，每个进程还有其他的标识符，由下面这些函数返回。

![](.\images\2024-01-15-13-10-29-image.png)

### 6.2 fork函数

一个现存进程调用f o r k函数是U N I X内核创建一个新进程的唯一方法。

```c
#include <sys/types.h>
#include <unistd.h>
pid_t fork(void);
```

fork函数有两个返回值，在父进程中返回子进程的pid，在子进程中返回0。

子进程会拷贝父进程的数据空间、堆、栈。对于正文段，若正文段是只读的，则会父子进程共享。

`注意：在有些实现方式中，对父进程的数据段和堆部分并不会完全拷贝。而是写时拷贝（Copy on Write）。`

创建子进程后，父子进程谁先执行是不确定的，主要看内核的调度算法。

#### 6.2.1 父子进程之间的文件共享

子进程会复制父进程的文件打开表，因此父子进程的文件打开表中相同的文件描述符指向内核文件表中的同一个表项，共享文件偏移量。

![](.\images\2024-01-15-15-16-29-image.png)

**fork失败的两种原因**

* 系统中已经有了太多的进程

* 该实际用户ID所拥有的进程数超过了系统限制

**fork的两种用法**

* 一个父进程希望复制自己，使父、子进程同时执行不同的代码段。这在网络服务进程
  中是常见的——父进程等待委托者的服务请求。当这种请求到达时，父进程调用 f o r k，使子进程处理此请求。父进程则继续等待下一个服务请求。

* 一个进程要执行一个不同的程序。这对shell是常见的情况。在这种情况下，子进程在
  从fork返回后立即调用exec

#### ~~6.2.2 vfork函数~~

也是用于创建一个新进程。但是此新进程的目的是未来exec一个新程序。比如shell就是这类程序的一个例子。

**和fork的区别**

* vfork不会完全复制父进程的地址空间

* vfork保证子进程先运行，只有子进程调用了exec或者exit时，父进程才会恢复执行。

* 若是在子进程中修改数据、进行函数调用、没有exec或者exit就返回可能会造成未知后果

`注意：此函数已经废弃了，尽量别使用`

### 6.3 exit函数

此函数用于控制进程的终止。进程有5种正常终止的方法和3种异常终止的方法，正常终止的方法就是return 0、exit、_exit、pthread_exit等等方法。异常终止方法如下

* 调用abort，它产生SIGABRT信号

* 当进程收到某些信号时。信号可由进程本身、其他进程或者内核产生。如前面调用abort就是产生SIGABRT信号。

* 最后一个线程对取消（cancellation）请求做出响应

不管进程如何终止，最后都会执行内核中的一段代码，这段代码为相应进程关闭所有打开的文件描述符并释放它使用的存储器。

#### 6.3.1 孤儿进程

我们希望进程终止时应该向父进程告诉它是如何终止的，exit函数就是通过传入终止状态来报告的。而若是父进程比子进程更早终止，那么子进程就变成孤儿进程，内核会把孤儿进程的父进程设置为init进程。流程如下：

> 当有一个进程终止时，内核会轮流检查所有正在活动的进程，判断是不是刚刚终止进程的子进程，若是，则内核会把他们的父进程的PID设置为1（init进程的PID）。

#### 6.3.2 僵死进程

指某些进程在终止后，父进程没有对其进行善后处理（获取终止子进程相关信息、释放它`仍然占用的资源`）。这些进程就叫做僵死进程。

**分析：进程终止后，文件描述符和占用的内存应该是由内核来回收的，但是为什么需要父进程来进行善后处理呢？**

> 因为在子进程终止后，虽然资源释放回收的工作是由内核来做的，但是内核为了父进程能够获取到子进程的终止状态，会为子进程在内存保留一定量的信息（进程ID、终止状态、使用CPU的时间），以便于父进程调用wait和waitpid时获取到它。因此，若是父进程没有调用wait或者waitpid去获取这部分信息，那么它这部分信息就无法释放会一直留在内存，直至父进程也终止，才会被父进程的父进程即bash进程释放掉。

### 6.4 wait和waitpid函数

当一个进程终止时，内核会向其父进程发送SIGCHLD信号。对于此信号，父进程可以忽略它也可以提供一个处理该信号的函数。系统默认行为是忽略此信号。虽然这个信号和wait函数没啥关系，但是wait和waitpid是阻塞的，因此，若是在捕获到SIGHCLD信号时调用wait和waitpid的话，就可以避免阻塞。

```c
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait(int *wstatus);
pid_t waitpid(pid_t pid, int *wstatus, int options);
```

**wait和waitpid的区别**

* 在一个子进程终止前， wait 使其调用者阻塞，而 waitpid 有一选择项，可使调用者不阻塞。

* waitpid并不等待第一个终止的子进程—它有若干个选择项，可以控制它所等待的进程。

**参数解析**

* wstatus保存进程的终止状态，若不关心终止状态，则可设为NULL，可以用如下三个宏函数来检查终止状态
  
  > ![](images/2024-01-29-00-39-40-image.png)

* pid指waitpid所等待的进程的id，根据pid的值不同，可以分为如下几种情况。

![](images/2024-01-29-00-44-06-image.png)

* option的值可以由如下几种情况。
  
  * 0：和wait一样，没回收到进程则阻塞
  
  * WNOHANG：若没回收到进程，则不阻塞，返回0
  
  * WUNTRACE：如果pid指定的子进程暂停了，则立即返回，并且不跟踪子进程的状态

`一个避免僵死进程的小技巧`

> 由于内核会把孤儿进程的父进程设置为init进程，init进程可以帮我们管理子进程的回收，因此，我们可以先fork一个子进程，然后再用这个子进程fork第二个子进程，然后第一个子进程退出，这样第二个子进程就成了孤儿，因此内核会把它的父进程设置成init进程。这样一来，我们就不用在父进程里担心子进程僵死了。

### 6.5 wait3和wait4

对应wait和waitpid函数的升级版，会要求内核返回终止进程所使用的资源摘要。原型如下。

```c
#include <sys/types.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/wait.h>
pid_t wait3(int *wstatus, int options,
                   struct rusage *rusage);
pid_t wait4(pid_t pid, int *wstatus, int options,
                   struct rusage *rusage);
```
