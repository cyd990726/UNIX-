## 进程控制

### 6.1进程标识

UNIX系统中，每个进程都有一个唯一的非负整型ID来标识。系统中有一些专用的进程ID，例如：ID为0的进程是调度进程（或者叫交换进程），ID为1的进程是init进程（自举结束后用于初始化系统），ID为2的进程通常是守护进程。

`注意：init进程是普通的用于进程，但是以超级用户的特权执行。且是所有孤儿进程的父进程！` 

除了进程ID，每个进程还有其他的标识符，由下面这些函数返回。

![](C:\Users\29155\AppData\Roaming\marktext\images\2024-01-15-13-10-29-image.png)

### 6.2 fork函数

一个现存进程调用f o r k函数是U N I X内核创建一个新进程的唯一方法。

```c
#include <sys/types.h>
#include <unistd.h>
pid_t fork(void);
```

fork函数有两个返回值，在父进程中返回子进程的pid，在子进程中返回0。

子进程会拷贝父进程的数据空间、堆、栈。对于正文段，若正文段是只读的，则会父子进程共享。

`注意：在有些实现方式中，对父进程的数据段和堆部分并不会完全拷贝。而是写时拷贝（Copy on Write）。`

创建子进程后，父子进程谁先执行是不确定的，主要看内核的调度算法。

#### 6.2.1 父子进程之间的文件共享

子进程会复制父进程的文件打开表，因此父子进程的文件打开表中相同的文件描述符指向内核文件表中的同一个表项，共享文件偏移量。

![](C:\Users\29155\AppData\Roaming\marktext\images\2024-01-15-15-16-29-image.png)

**fork失败的两种原因**

* 系统中已经有了太多的进程

* 该实际用户ID所拥有的进程数超过了系统限制

**fork的两种用法**

* 一个父进程希望复制自己，使父、子进程同时执行不同的代码段。这在网络服务进程
  中是常见的——父进程等待委托者的服务请求。当这种请求到达时，父进程调用 f o r k，使子进程处理此请求。父进程则继续等待下一个服务请求。

* 一个进程要执行一个不同的程序。这对shell是常见的情况。在这种情况下，子进程在
  从fork返回后立即调用exec
